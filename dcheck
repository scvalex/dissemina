#!/usr/bin/env python

import sys, re, urllib2, sha, optparse

last_comment = ""
ignore_checks = True
data = "" # data received from server
headers = None # headers received from server
url = "" # last url requested
status = 0
server = "http://localhost:6462/"
verbose = 0

def errmsg(s):
	if verbose >= 0:
		print "#ERR", s

def infomsg(s):
	if verbose > 0:
		print "#INFO", s

def show_last_comment():
	global last_comment
	if last_comment and (verbose > 0):
		print last_comment,
		last_comment = None

def do_comment(line):
	globals()["last_comment"] = line

def do_command(line):
	global ignore_checks, data, headers, status, url
	ignore_checks = False
	data, headers, url = "", None, ""
	if re.match("^GET", line):
		url = line.split()[1]
		status = "200"
		try:
			x = urllib2.urlopen(server + url)
			data = x.read()
			headers = x.info()
		except urllib2.HTTPError, e:
			status = re.match("[A-z ]*([0-9]*)", e.__str__()).groups()[0]
	else:
		errmsg("Unknown action: " + line.split()[0])
		ignore_checks = True

def do_check(line):
	if ignore_checks:
		return
	line = line.strip()
	if re.match("^status", line):
		show_last_comment()
		infomsg("checking received status (%s) against expected (%s)" %
				(line.split()[1], status))
		if status == line.split()[1]:
			print "OK"
		else:
			print "FAILED"
	elif re.match("^data", line):
		infomsg("checking data from " + url)
		try:
			if sha.new(data).digest() == sha.new(open(url[1:]).read()).digest():
				print "OK"
			else:
				print "FAILED"
		except:
			print "FAILED"
	else:
		errmsg("Unknown check: " + line.split()[0])

matchpats = ("^[\t ]*\n",	# match an empty line
			 "^[\t ]*#",		# match a comment
			 "^[A-z_]",		# match a command
			 "^[\t ]+[A-z_]", # match a check
			 )
matchacts = (lambda(l): None,
			 do_comment,
			 do_command,
			 do_check,
			 )

def main():
	global verbose

	p = optparse.OptionParser(description = "runs checks against a server")
	p.add_option("--verbose", "-v", action="store_true", help="show warnings")
	p.add_option("--silent", "-s", action="store_true", help="kill all nonessential output")
	options, arguments = p.parse_args()
	verbose = options.verbose and 1 or 0
	verbose = options.silent and -1 or verbose

	for line in sys.stdin:
		for i in xrange(len(matchpats)): # I really need an orderd dict
			if re.match(matchpats[i], line):
				matchacts[i](line)
				break

if __name__ == "__main__":
	main()

